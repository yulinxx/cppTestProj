/* K-均值算法 */
#include <iostream>

#include <math.h>

#include <iostream>
#include <sstream>
#include <vector>
#include <string>

// https://github.com/genbattle/dkm
#include "K-meansAlgorithm-dkm.hpp"

int main()
{
    //  //训练函数的签名
    // std::tuple>, std::vector> kmeans_lloyd(const std::vector>&data,   //训练数据集， 必填
    //                                        uint32_t k,                // K值（也就是目标类别的数量）， 必填
    //                                        uint64_t max_iter = 0,     //最大迭代次数，默认不填
    //                                        T min_delta = -1.0)        //最小的停止阈值，默认不填

    // 返回的结果是一个Tuple
    // Tuple[0]:返回的是数据集聚类中心的列表(长度为K)
    // Tuple[1]:返回的是输入数据集对应的标签

    // 数据为Python代码提取所得
    // 数据图形化参考:
    // https://github.com/yulinxx/python-collection/blob/master/algorithm/K-meansAlgorithm.py
    std::string trData = "-0.623,9.188,0.54,5.305,-2.300,7.546,4.225,2.824,-3.181,9.445,-8.684,7.548,1.065,3.927,-6.435,\
    -7.058,-8.704,7.105,2.716,3.163,3.685,2.626,-2.843,7.421,4.997,2.376,-3.026,8.553,1.043,3.014,-3.784,7.651,4.743,\
    1.327,4.283,2.569,0.997,3.003,-2.077,7.203,-1.296,9.095,5.915,3.679,-2.195,8.702,1.316,3.117,2.794,3.645,-2.716,\
    7.523,-6.324,-6.308,1.658,3.108,3.078,2.184,-7.702,-6.034,-5.773,8.279,3.075,3.162,1.234,3.835,-7.487,7.562,-8.315,\
    -5.117,3.963,0.736,4.525,2.424,2.859,3.074,-8.629,8.164,3.134,2.956,-4.914,8.105,5.761,2.941,-6.042,-6.661,-6.023,9.907,\
    2.755,4.829,-8.777,6.278,-2.016,10.328,-6.251,-7.707,1.064,4.761,-4.004,-8.449,-9.553,7.547,2.765,6.975,-7.782,-7.894,\
    -7.726,7.325,-3.938,8.785,-10.785,5.603,3.874,2.036,-3.384,8.555,-10.562,8.228,-7.853,-6.137,-2.888,7.587,-9.596,7.926,\
    2.574,3.165,2.606,6.305,-6.231,-6.335,5.235,2.304,-8.594,-8.502,-6.318,-7.269,-6.266,-5.394,-7.482,-6.922,3.298,3.714,\
    -7.972,-8.678,-10.165,7.085,2.417,4.755,-9.084,8.058,-2.743,9.212,-9.786,6.814,-9.193,6.855,2.275,3.836,-3.147,10.726,\
    -5.918,-8.796,-3.961,7.303,-2.116,8.197,2.845,3.885,-2.403,8.505,-7.593,-6.311,-10.888,8.116,5.269,3.331,3.453,2.617,3.983,\
    4.122,2.868,3.068,2.496,2.488,-5.494,9.545,2.357,5.859,-3.789,9.677,-2.097,9.121,3.205,3.573,-7.184,7.812,3.194,0.557,1.166,\
    4.323,-10.378,6.931,-10.863,7.742,5.378,3.347,-5.195,-6.338,-1.651,7.041,-2.863,9.068,-4.783,8.735,6.161,0.394,-2.955,8.005,\
    3.107,2.356,-8.885,9.459,2.015,4.975,4.668,3.098,5.771,0.768,-1.676,9.006,-3.933,9.187,-1.561,7.299,-5.174,-6.991,-10.632,\
    8.213,-9.313,5.029,-9.368,7.209,-5.519,-7.085,-7.968,8.391,-6.338,6.515,-1.798,11.083,-5.025,-6.011,1.591,2.452,-0.208,\
    3.046,-10.584,7.926,-1.992,9.452,5.615,0.035,-9.655,5.118,3.103,1.609,-2.236,11.608,-2.262,9.069,-3.738,9.595,-2.376,10.237,\
    3.325,1.835,-5.635,-8.579,1.026,2.492,-3.644,8.962,-8.111,7.525,-2.124,8.065,3.578,1.937,3.404,5.359,-2.478,7.429,2.146,4.772,\
    -5.648,-7.728,3.965,2.707,-7.342,-7.916,4.008,3.049,-6.232,-7.984,-6.307,-7.402,4.783,1.364,-1.961,8.787,1.329,4.068,-7.545,-7.779,\
    -8.862,8.051,-2.893,8.175,4.145,1.702,-8.718,6.236,-8.642,6.495,0.013,4.291,4.101,0.089,-2.579,8.454,-7.332,7.055,1.185,2.573,\
    2.665,1.237,4.384,2.663,2.383,3.445,-6.959,-7.555,-2.726,9.935,4.978,2.708,4.231,3.603,-1.033,8.582,3.864,1.563,-10.653,9.057,\
    4.305,0.744,-6.778,-7.742,-6.128,-6.005,-10.816,6.942,-7.996,6.363,5.075,1.494,-8.283,-7.198,-6.185,-7.778,2.886,6.348,-3.528,\
    9.993,-9.704,6.752,-7.254,-6.855,5.304,2.653,2.378,3.416,-6.552,-6.033,-2.264,7.865,-7.443,-8.795,-5.154,-8.386,-8.585,8.008,\
    -9.538,6.023,-6.455,-7.921,2.584,5.935,4.915,1.148,-7.235,6.999,-6.366,-7.085,2.494,2.598,5.505,1.215,-8.569,6.329,-2.907,8.033,\
    -3.776,8.614,-6.547,-7.076,-6.223,-7.601,-2.084,10.345,-6.925,-7.374,-6.621,7.315,0.344,4.148,-7.743,-4.486,-2.336,10.429,3.687,2.595,\
    -7.225,5.589,-6.535,6.653,-4.637,-5.996,1.588,2.639,-7.718,5.115,-8.182,8.942,2.676,4.857,-9.845,6.359,1.822,3.288,5.999,2.182,\
    -9.537,6.308,2.707,4.245,-9.709,7.911,2.817,6.039,-8.163,6.348,4.145,4.351,5.559,2.534,-6.008,-6.482,1.487,3.126,3.296,1.231,4.121,\
    2.556,4.231,1.424,2.564,3.358,-2.593,9.286,-9.568,8.665,6.427,2.743,-6.828,-7.315,-0.366,3.432,-5.846,-7.777,-8.244,7.224,2.585,5.809,\
    2.275,5.192,-6.098,-5.369,-6.115,-6.667,3.893,2.917,0.193,3.301,-8.826,7.445,-6.853,-6.152,-9.254,7.202,3.616,3.776,-7.491,-5.565,\
    2.726,3.646,-6.158,-7.783,2.025,3.871,-10.342,-7.236,-1.397,9.292,2.421,3.414,6.858,2.195,5.646,1.591,-3.389,8.108,3.833,4.568,3.965,\
    2.137,-5.941,-6.187,3.401,1.833,-8.712,6.834,-6.022,-6.549,-6.185,-6.165,-2.934,7.789,-2.702,9.287,-8.068,7.153,4.645,0.259,5.149,\
    5.453,0.039,4.844,2.176,3.908,-7.825,7.479,-1.522,10.145,-2.856,8.154,4.108,2.043,4.998,2.545,-7.353,-6.747,-5.105,-6.595,-7.706,\
    -7.794,2.568,3.792,3.333,2.408,-9.115,8.142,4.755,2.996,-6.238,-7.654,-10.887,7.915,-3.709,9.919,-9.605,7.741,-7.215,-6.676";

    std::stringstream ss(trData);
    std::string item;
    std::vector<double> values;
    while (std::getline(ss, item, ','))
        values.push_back(std::stod(item));

    // 实际训练； 将4种颜色分成3类
    //  std::vector<std::array<float, 2>> data{{1.f, 1.f}, {2.f, 2.f}, {1200.f, 1200.f}, {2.f, 2.f}};

    std::vector<std::array<float, 2>> data;
    data.reserve(values.size() / 2);

    for (size_t i = 0; i < values.size(); i += 2)
        data.emplace_back(std::array<float, 2>{static_cast<float>(values[i]), static_cast<float>(values[i + 1])});

    // 返回数据的中心点，以及数据所属的哪个簇
    auto cluster_data = dkm::kmeans_lloyd(data, 5);
    // std::tuple<std::vector<std::array<T, N>>, std::vector<uint32_t>>
    auto vCenter = std::get<0>(cluster_data);

    size_t i = 0;
    for (auto& pt : vCenter)
    {
        std::cout << "\nCenter " << i++ << " ";
        for (const auto& element : pt)
            std::cout << element << " ";
    }

    std::cout << "\n\n\nGroup:";
    auto vGroup = std::get<1>(cluster_data);

    i = 0;
    for (auto& g : vGroup)
    {
        std::cout << "Pt " << i++ << " is Group" << g << std::endl;
    }

    int m = 0;

    // 以下是训练结果的可视化
    //  vector model_label;
    //  std::cout << "Means:" << std::endl;
    //  for (const auto& mean : std::get<0>(cluster_data))
    //  {
    //      std::cout << "\t(" << mean[0] << "," << mean[1] << ","<< mean[2] <<"" << ")" << std::endl;
    //  }
    //  std::cout << "\nCluster labels:" << std::endl;    std::cout << "\tPoint:";
    //  for (const auto& point : data)
    //  {
    //      std::stringstream value;
    //      value << "(" << point[0] << "," << point[1]  << ","<< point[2] << ")";
    //      std::cout << std::setw(14) << value.str();    }
    //      std::cout << std::endl;    std::cout << "\tLabel:";
    //      for (const auto& label : std::get<1>(cluster_data))
    //      {
    //          std::cout << std::setw(14) << label;
    //          model_label.push_back(label);
    //      }
    //      std::cout << std::endl;
    //  }
}

// #define Number 100 // 模式样本的最大维数与个数

// struct Node // 定义了一个用于存放模式样本的数据结构
// {
//     double dX = 0.0;
//     double dY = 0.0;

//     int kinds = 0;                // 模式样本所属类别，0为未分类状态
// };

// double Distance(const Node& X, const Node& Z, int n) // 欧式距离计算函数
// {
//     double result = 0;
//     result += std::pow(X.dX - Z.dX, 2);
//     result += std::pow(X.dY - Z.dY, 2);
//     result = sqrt(result);
//     return result;
// }

// void Add(Node &result, Node X, int n) // 矩阵加法
// {
//     result.dX += X.dX;
//     result.dY += X.dY;
// }

// void Kmeans(int k, std::vector<Node> vX, std::vector<Node> vZ, int m) // K-means算法中迭代计算函数
// {
//     int number = 0;                 // 用于记录迭代计算轮数
//     double *D = new double[k];      // 用于存放迭代计算中距离的变量
//     int *N = new int[k]();          // 用于统计每个模式类中的模式样本数
//     int(*S)[100] = new int[k][100]; // 用于统计每个模式类中的模式样本
//     int condition = 1;              // 算法结束的条件

//     while (1)                       // 迭代运算
//     {
//         number++;
//         condition = 1;
//         for (int i = 0; i < k; i++) // 对Ni进行初始化
//         {
//             N[i] = 0;
//         }

//         /* 分别计算各点与聚类中心的距离 */
//         for (size_t i = 0; i < vX.size(); i++)
//         {
//             for (int j = 0; j < k; j++)
//             {
//                 D[j] = Distance(vX[i], vZ[j]);
//             }

//             int temp = 0;
//             for (int j = 0; j < k; j++)
//             {
//                 if (D[temp] > D[j])
//                     temp = j;

//                 X[i].kinds = temp + 1;
//             }
//         }

//         /* 统计每个模式类中的样本数和样本 */
//         for (int i = 0; i < k; i++)
//         {
//             // std::cout << "第" << number << "次迭代计算后，模式类" << i + 1 << "中包括{ ";
//             int temp = 0;
//             for (int j = 0; j < m; j++)
//             {
//                 if (X[j].kinds == (i + 1))
//                 {
//                     N[i]++;
//                     S[i][temp] = j;
//                     std::cout << "X" << S[i][temp] + 1 << " ";
//                     temp++;
//                 }
//             }
//             std::cout << "}\n";
//         }

//         /* 计算新的聚类中心 */
//         Node oldZ = new Node[k]; // 保存本次计算前的聚类中心
//         for (int i = 0; i < k; i++)
//         {
//             oldZ[i].dX = Z[i].dX;
//             oldZ[i].dY = Z[i].dY;
//         }
//         // 计算聚类中心
//         for (int i = 0; i < k; i++)
//         {
//             Node result;
//             for (int j = 0; j < N[i]; j++)
//             {
//                 Add(result, X[S[i][j]], n);
//             }

//             Z[i].dX = (result.dX / N[i]);
//             Z[i].dY = (result.dY / N[i]);
//         }

//         /* 判断是否符合迭代结束条件 */
//         for (int i = 0; i < k; i++)
//         {
//             std::cout << "第" << number << "次迭代计算后聚类中心Z" << i + 1 << "=( ";
//             std::cout << Z[i].dX << " ";
//             std::cout << Z[i].dY << " ";
//             std::cout << ")\n";
//         }

//         for (int i = 0; i < k; i++)
//         {
//             if (Z[i].dX != oldZ[i].dX && Z[i].dY != oldZ[i].dY)
//                 condition = 0;
//         }

//         delete[] oldZ;

//         if (condition == 1)
//             break;
//     }
// }

// int main()
// {
//     /* 数据的输入与初始化 */
//     int n = 2; // 模式样本的维数
//     int m = 4; // 模式样本的个数
//     // std::cout << "请输入需要分类的模式样本的维数：";
//     // cin >> n;
//     // std::cout << "请输入需要分类的模式样本的个数：";
//     // cin >> m;
//     // std::cout << "请输入需要分类的模式样本：\n";

//     std::string trData = "-0.623,9.188,0.54,5.305,-2.300,7.546,4.225,2.824,-3.181,9.445,-8.684,7.548,1.065,3.927,-6.435,\
//     -7.058,-8.704,7.105,2.716,3.163,3.685,2.626,-2.843,7.421,4.997,2.376,-3.026,8.553,1.043,3.014,-3.784,7.651,4.743,\
//     1.327,4.283,2.569,0.997,3.003,-2.077,7.203,-1.296,9.095,5.915,3.679,-2.195,8.702,1.316,3.117,2.794,3.645,-2.716,\
//     7.523,-6.324,-6.308,1.658,3.108,3.078,2.184,-7.702,-6.034,-5.773,8.279,3.075,3.162,1.234,3.835,-7.487,7.562,-8.315,\
//     -5.117,3.963,0.736,4.525,2.424,2.859,3.074,-8.629,8.164,3.134,2.956,-4.914,8.105,5.761,2.941,-6.042,-6.661,-6.023,9.907,\
//     2.755,4.829,-8.777,6.278,-2.016,10.328,-6.251,-7.707,1.064,4.761,-4.004,-8.449,-9.553,7.547,2.765,6.975,-7.782,-7.894,\
//     -7.726,7.325,-3.938,8.785,-10.785,5.603,3.874,2.036,-3.384,8.555,-10.562,8.228,-7.853,-6.137,-2.888,7.587,-9.596,7.926,\
//     2.574,3.165,2.606,6.305,-6.231,-6.335,5.235,2.304,-8.594,-8.502,-6.318,-7.269,-6.266,-5.394,-7.482,-6.922,3.298,3.714,\
//     -7.972,-8.678,-10.165,7.085,2.417,4.755,-9.084,8.058,-2.743,9.212,-9.786,6.814,-9.193,6.855,2.275,3.836,-3.147,10.726,\
//     -5.918,-8.796,-3.961,7.303,-2.116,8.197,2.845,3.885,-2.403,8.505,-7.593,-6.311,-10.888,8.116,5.269,3.331,3.453,2.617,3.983,\
//     4.122,2.868,3.068,2.496,2.488,-5.494,9.545,2.357,5.859,-3.789,9.677,-2.097,9.121,3.205,3.573,-7.184,7.812,3.194,0.557,1.166,\
//     4.323,-10.378,6.931,-10.863,7.742,5.378,3.347,-5.195,-6.338,-1.651,7.041,-2.863,9.068,-4.783,8.735,6.161,0.394,-2.955,8.005,\
//     3.107,2.356,-8.885,9.459,2.015,4.975,4.668,3.098,5.771,0.768,-1.676,9.006,-3.933,9.187,-1.561,7.299,-5.174,-6.991,-10.632,\
//     8.213,-9.313,5.029,-9.368,7.209,-5.519,-7.085,-7.968,8.391,-6.338,6.515,-1.798,11.083,-5.025,-6.011,1.591,2.452,-0.208,\
//     3.046,-10.584,7.926,-1.992,9.452,5.615,0.035,-9.655,5.118,3.103,1.609,-2.236,11.608,-2.262,9.069,-3.738,9.595,-2.376,10.237,\
//     3.325,1.835,-5.635,-8.579,1.026,2.492,-3.644,8.962,-8.111,7.525,-2.124,8.065,3.578,1.937,3.404,5.359,-2.478,7.429,2.146,4.772,\
//     -5.648,-7.728,3.965,2.707,-7.342,-7.916,4.008,3.049,-6.232,-7.984,-6.307,-7.402,4.783,1.364,-1.961,8.787,1.329,4.068,-7.545,-7.779,\
//     -8.862,8.051,-2.893,8.175,4.145,1.702,-8.718,6.236,-8.642,6.495,0.013,4.291,4.101,0.089,-2.579,8.454,-7.332,7.055,1.185,2.573,\
//     2.665,1.237,4.384,2.663,2.383,3.445,-6.959,-7.555,-2.726,9.935,4.978,2.708,4.231,3.603,-1.033,8.582,3.864,1.563,-10.653,9.057,\
//     4.305,0.744,-6.778,-7.742,-6.128,-6.005,-10.816,6.942,-7.996,6.363,5.075,1.494,-8.283,-7.198,-6.185,-7.778,2.886,6.348,-3.528,\
//     9.993,-9.704,6.752,-7.254,-6.855,5.304,2.653,2.378,3.416,-6.552,-6.033,-2.264,7.865,-7.443,-8.795,-5.154,-8.386,-8.585,8.008,\
//     -9.538,6.023,-6.455,-7.921,2.584,5.935,4.915,1.148,-7.235,6.999,-6.366,-7.085,2.494,2.598,5.505,1.215,-8.569,6.329,-2.907,8.033,\
//     -3.776,8.614,-6.547,-7.076,-6.223,-7.601,-2.084,10.345,-6.925,-7.374,-6.621,7.315,0.344,4.148,-7.743,-4.486,-2.336,10.429,3.687,2.595,\
//     -7.225,5.589,-6.535,6.653,-4.637,-5.996,1.588,2.639,-7.718,5.115,-8.182,8.942,2.676,4.857,-9.845,6.359,1.822,3.288,5.999,2.182,\
//     -9.537,6.308,2.707,4.245,-9.709,7.911,2.817,6.039,-8.163,6.348,4.145,4.351,5.559,2.534,-6.008,-6.482,1.487,3.126,3.296,1.231,4.121,\
//     2.556,4.231,1.424,2.564,3.358,-2.593,9.286,-9.568,8.665,6.427,2.743,-6.828,-7.315,-0.366,3.432,-5.846,-7.777,-8.244,7.224,2.585,5.809,\
//     2.275,5.192,-6.098,-5.369,-6.115,-6.667,3.893,2.917,0.193,3.301,-8.826,7.445,-6.853,-6.152,-9.254,7.202,3.616,3.776,-7.491,-5.565,\
//     2.726,3.646,-6.158,-7.783,2.025,3.871,-10.342,-7.236,-1.397,9.292,2.421,3.414,6.858,2.195,5.646,1.591,-3.389,8.108,3.833,4.568,3.965,\
//     2.137,-5.941,-6.187,3.401,1.833,-8.712,6.834,-6.022,-6.549,-6.185,-6.165,-2.934,7.789,-2.702,9.287,-8.068,7.153,4.645,0.259,5.149,\
//     5.453,0.039,4.844,2.176,3.908,-7.825,7.479,-1.522,10.145,-2.856,8.154,4.108,2.043,4.998,2.545,-7.353,-6.747,-5.105,-6.595,-7.706,\
//     -7.794,2.568,3.792,3.333,2.408,-9.115,8.142,4.755,2.996,-6.238,-7.654,-10.887,7.915,-3.709,9.919,-9.605,7.741,-7.215,-6.676";

//     std::stringstream ss(trData);
//     std::string item;
//     std::vector<double> values;
//     while (std::getline(ss, item, ','))
//         values.push_back(std::stod(item));

//     size_t nSz = values.size() / 2;

//     std::vector<Node> vNodes;
//     vNodes.reserve(nSz);

//     for (size_t i = 0; i + 2 < values.size();)
//     {
//         vNodes.emplace_back(Node());

//         vNodes[i].dX = values[i++];
//         vNodes[i].dY = values[i++];
//     }

//     int k = 5; // 用于K-means算法的k值

//     /* 根据用户输入的k值初始化聚类中心 */
//     // Node *Z = new Node[k]; // 聚类中心
//     std::vector<Node> vNodesX;
//     for (int i = 0; i < k; i++)
//     {
//         vNodesX.emplace_back(Node());
//         for (int j = 0; j < n; j++)
//         {
//             vNodesX[i].dX = vNodes[i].dX;
//             vNodesX[i].dY = vNodes[i].dY;
//         }
//     }

//     /* 迭代计算聚类中心 */
//     Kmeans(k, vNodes, vNodesX, m);

//     /* 输出计算结果 */
//     std::cout << "Res:\n";
//     for (int i = 0; i < k; i++)
//     {
//         // std::cout << "聚类中心Z" << i + 1 << "=( ";
//         std::cout << "Center Z" << i + 1 << "=( ";
//         for (int j = 0; j < n; j++)
//         {
//             std::cout << Z[i].vecElement[j] << " ";
//         }
//         std::cout << ")\n";
//     }

//     delete[] Z;
//     return 0;
// }