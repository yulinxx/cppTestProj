
/*
https://blog.csdn.net/fl2011sx/article/details/128314495
模板的链接方式。在一个单独的.cpp文件中使用模板并不会有什么链接性问题，但如果在多个文件中都要使用呢？
自然要通过「头文件声明+链接」的方式来完成了。
但模板本身又很特殊，它本身不是可用的代码，而是代码生成器，因此编译器会在编译期用模板来生成代码，
注意，这个时候还没有开始链接！所以问题就产生了，假如我们按照直觉和习惯，把模板的声明和定义分文件来写，会怎么样呢？请看下面示例：
---- tmp.h ---- 

#pragma once

template <typename T>
void f(const T &t); // 声明


---- tmp.cpp ---- 

#include "tmp.h"

template <typename T>
void f(const T &t) {} // 实现


---- main.cpp ---- 

#include "tmp.h"

int main() {
  f(1);   // f<int>
  f(1.0); // f<double>
  return 0;
}

如果我们真的这么做了，你会发现链接时会报错。原因是这样的，
我们在tmp.h中的这种写法，并不是「声明了一个模板函数」，模板函数本不是函数，是不需要声明的，
大家记住模板永远是生成代码的工具。

所以tmp.h中的写法是「声明了一组函数」，包括我们在main函数中使用的f<int>和f<double>，
之所以能通过编译，就是因为tmp.h中存在它们的声明。
换句话说，template <typename T> void f(const T &);
相当于
void f<int>(const int &);
void f<double>(const double &);
void f<char *>(char *const &);……
这一系列的「函数声明」。

所以，编译是没问题的，但是链接的时候会报找不到f<int>和f<double>的实现。
这是为什么呢？明明我在tmp.cpp中实现了呀！
那我们来「换位思考一下」，假如你是编译器，我们知道「编译」过程是单文件行为，那么你现在来编译main.cpp，
首先进行预处理，把#include替换成对应头文件内容，那么main.cpp就变成了:

template <typename T>
void f(const T &t);

int main() {
  f(1); // f<int>
  f(1.0); // f<double>
  return 0;
}

上面的f是函数声明，下面编译主函数的时候，根据参数推导出了f<int>和f<double>，
于是，通过上面的「模板函数声明」生成了2条实际的「函数声明」语句，也就是：
void f<int>(const int &);
void f<double>(const double &);

调用都是符合声明的，OK，结束编译，我们得到了main.o。

好了，下面我们来编译tmp.cpp。同理，先做预处理，得到了：
template <typename T>
void f(const T &t);

template <typename T>
void f(const T &t) {}

这时，问题的关键点来了！，这个模板函数f在当前这个编译单元中，并没有任何实例化，那么你自然就不知道应当按这个模板来生成哪些实例。
所以，你只能什么都不做，很无奈地生成了一个空白的tmp.o。

最后，main.o和tmp.o链接，main.o中的f<int>和f<double>都找不到实现，所以链接报错。

这就是模板的链接方式问题，由于模板都是编译期进行实例化，
因此，必须在编译期就得知道需要哪些实例化，然后把这些实例化后的代码编译出来，再去参与链接，才能保证结果正确。

所以，要保证编译期能知道所有需要的实例，我们只能把模板实现放在头文件里。
这样，每一个编译单元都能根据自己需要的实例来生成代码。

上面的代码应该改造成：

---- tmp.h ---- 

#pragma once
template <typename T>
void f(const T &t);

template <typename T>
void f(const T &t) {} // 当然，文件内部没有声明依赖关系的时候，声明和实现可以合并

---- main.cpp ---- 

#include "tmp.h"

int main() {
  f(1);
  f(1.0);

  return 0;
}

这时，在编译main.cpp时，就会把f<int>和f<double>的实例都编译出来，这样就不会链接报错了。

但这样会引入另一个问题，如果多个.cpp引入同一个含有模板的.h文件，并做了相同的实例化，
会不会生成多份函数实现呢？这样链接的时候不是也会报错吗？

设计编译器的大佬们自然也想到这个问题了，那么解决方法就是，通过模板实例出的内容，会打上一个全局标记，
最终链接时只使用一份（毕竟是从同一份模板生成出来的，每一份自然是相同的）。
再换句更通俗易懂的说法就是模板实例一定是inline的，编译器会给每个模板实现自动打上inline标记，确保链接时全局唯一。

现在我们再回头看一下全特化模板，全特化模板已经是实例化过的了，因此并不会出现编译期不知道要怎么实例化的问题。



.inl 文件是指内联文件（Inline File）的扩展名。它通常用于包含实现细节或模板函数/类的定义。
与头文件（.h 或 .hpp）不同，.inl 文件通常被直接包含在其他源文件中，而不是作为独立的编译单元进行编译。

内联文件的主要作用是将实现细节与接口分离，同时避免多次包含相同的实现代码。
在使用内联文件时，将实现代码放在 .inl 文件中，并在需要使用的源文件中包含该文件。

一种常见的用法是将模板函数或类的定义放在 .inl 文件中，并在头文件中进行声明。
这样可以避免在每个使用该模板的源文件中都重复定义一次。

需要注意的是，.inl 文件的使用并不是强制性的，这只是一种常见的代码组织方式。
可以根据项目的需求和个人偏好来决定是否使用内联文件。

总结起来，.inl 文件是一种用于包含实现细节或模板函数/类定义的文件，
用于将实现代码与接口分离，并避免重复定义的情况发生。

*/

// #include "baseTemplate.h"  // 包含头文件

inline void inlFileTestClass::foo() {
    // 函数实现
    std::cout<<"call inlFileTestClass::foo()"<<std::endl; 
}